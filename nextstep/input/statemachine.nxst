static {
  class Machine {      
    states: State* //* means 'set'
    initial: State
    
    invariants {
      // initial must be a known state
      initial in states
      // all states that are targeted in the transitions must be part of the machine
      states.transitions.target in states 
    }
  }
  
  class State {
    transitions: Trans*
  }

  class Trans  {
    target: State
  }
}

runtime {
  class Runtime  {
    machine: Machine
    current: State
    visited: Visit*
    
    invariants {
      // the current state must be part of the states connected to the machine
      current in machine.states

      forall s:machine.states | one (visited.state & s)
      forall v1:visited, v2:visited | v1 != v2 => v1.state != v2.state
    }
  } 
  
  class Visit {
    state: State
    nr: int
    
    // Nr must be positive
    invariant: nr >= 0
  }
}

migration {
  // if the old current state does not exist anymore in the new machine states then the new current state is the machine's initial state
    not old[Runtime.current] in new[Runtime.machine.states] => (new[Runtime.current] = new[Runtime.machine.initial])
}

input {
  old static
    Machine doors 
      states = opened, closed
      initial = closed
    
    State opened
      transitions = t2
    
    State closed
      transitions = t1
              
    Trans t1 
      target = opened
    
    Trans t2
      target = closed
    
  old runtime
    Runtime x 
      machine = doors 
      current = closed 
      visited = v1, v2
      
    Visit v1 
      state = opened 
      nr = 1
  
    Visit v2 
      state = closed 
      nr = 1
    
  new static
    Machine doors 
      states = opened, closed, locked 
      initial = closed
      
    State opened 
      transitions = t2
    
    State closed 
      transitions = t1
    
    State locked
      transitions = t3, t4  
      
    Trans t1 
      target = opened
  
    Trans t2 
      target = closed
    
    Trans t3
      target = locked
    
    Trans t4
      target = closed
}
