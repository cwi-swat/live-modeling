static {
  class Machine {      
    states: State* //* means 'set'
    initial: State
    
    invariants {
      // initial must be a known state
      initial in states
      // all states that are targeted in the transitions must be part of the machine
      states.transitions.target in states
    }
  }
  
  class State {
    transitions: Trans*
  }

  class Trans  {
    target: State
  }
}

runtime {
  class Runtime  {
    machine: Machine
    current: State
    visited: Visit*
    trace: Step*
    
    invariants {
      // the current state must be part of the states connected to the machine
      current in machine.states

      // visited is defined for all states of the machine
      forall s: machine.states | (exists v: visited | v.state = s) && 
                           count(visited where (visited.state = s)) = 1

      // both the trace from and to targets must be part of the states of the machine
      trace.from ++ trace.to in machine.states
      
      // all to targets in the trace must be reachable from the initial state of the machine
      trace.to in ^machine.initial.transitions.target
      
      // if there is a trace, the current state must be part of it
      some trace => exists s: trace | s.to = current
      
      // the nr of times that a state was visited depends of the nr of occurences in the trace
      forall v: visited | v.nr = count(trace where (trace.from = v.state))
    }
  } 
  
  class Visit {
    state: State
    nr: int
    
    // Nr must be positive
    invariant: nr >= 0
  }
  
  class Step {
    from: State
    to: State
    
    // it must be possible to transition to the given 'to' state from the given 'from' state
    invariant: exists t: from.transitions | t.target = to
  }
}

migration {
  // if the old current state does not exist anymore in the new machine states then the new current state is the machine's initial state
  //forall old, new: Runtime | 
  not (old.current in new.machine.states) => (new.current = new.machine.initial)
}

input {
  old static
  doors: Machine ( states: opened, closed, locked; initial: closed)
  opened: State (transitions: t2 )
  closed: State (transitions: t1, t3)
  locked: State (transitions: t4)
  t1: Trans (target: opened)
  t2: Trans (target: closed)
  t3: Trans (target: locked)
  t4: Trans (target: closed)
  
  old runtime
  x: Runtime (machine: doors; current: locked; visited: v1, v2, v3)
  v1: Visit (state: opened; nr: 0)
  v2: Visit (state: closed; nr: 1)
  v3: Visit (state: locked; nr: 0)
  
  new static
  doors: Machine ( states: opened, closed; initial: closed)
  opened: State (transitions: t2 )
  closed: State (transitions: t1 )
  t1: Trans (target: opened)
  t2: Trans (target: closed)
}
