static {
  class Task {
     actions: Action*
     order: OrderedPair*
  }

  class Subsystem {
    ssa: Action*
  }

  class Action {}

  class OrderedPair {
    action: Action
    succeeds: Action
  }
}

runtime {
  class Queue  {
    subsystem: Subsystem
    actions: QueuedAction*

    invariants {
      // Each queue corresponds to a subsystem (and contains actions only of this subsystem)
      forall qa: actions | qa.item in subsystem.ssa 
    }
  }

  class QueuedAction {
    item: Action
    index: int
  }

  class Runtime  {
    request: Action*
    queues: Queue*
    task: Task
 
    invariants {
      // Current request is a subset of the current task
      request in task.actions 
    
      // Each queued action of the task is removed from the request
      forall q: queues | no (q.actions.item & request)

      // An action cannot be queued if it succeeds an action that hasn't been queued yet (= that is still in the request)
      forall o: task.order | 
        o.succeeds in request => o.action in request 

      // An action cannot be queued if it succeeds an action that hasn't been executed yet (= that is still in a queue)
      // unless these actions belong to one subsystem
      forall o: task.order | 
        (exists q: Queue | o.succeeds in q.actions.item &&
          not (o.action in q.subsystem.ssa) ) =>
          not (exists q: Queue | o.action in q.actions.item)      


      // If actions from one subsystem are ordered, then they should be queued in the corresponding order
      forall o: task.order |
        (exists q: Queue | o.succeeds in q.actions.item && o.action in q.actions.item)
          =>
        (forall qa1: queues.actions, qa2: queues.actions | 
                (qa1.item = o.succeeds) && (qa2.item = o.action) => qa1.index > qa2.index)                    
    } 
  }
}

migration {
  // If we add new actions to the task, put them into request
  //(forall old, new : Runtime |)
  new[Runtime.task.actions] -- old[Runtime.task.actions] in new[Runtime.request] 
  
  //(new Task.actions -- old Task.actions) in new Runtime.request.actions
}

input {
  old static
    Task t
      actions = up, down, grab
      order = op1, op2
    Subsystem arm
      ssa = up, down
    Subsystem hand
      ssa = grab
    Action up
    Action down
    Action grab
    OrderedPair op1
      action = grab
      succeeds = down
    OrderedPair op2
      action = up
      succeeds = down 
  old runtime
    Runtime x
      request = grab
      queues = qarm, qhand
      task = t
    Queue qarm
      subsystem = arm
      actions = qa1, qa2
    Queue qhand
      subsystem = hand
      actions = []
    QueuedAction qa1
      item = down
      index = 1
    QueuedAction qa2
      item = up
      index = 2
  new static
    Task t
      actions = up, down, grab
      order = op1, op2
    Subsystem arm
      ssa = up, down
    Subsystem hand
      ssa = grab
    Subsystem trigger
      ssa = switch
    Action up, down, grab, switch
    OrderedPair op1
      action = grab
      succeeds = down
    OrderedPair op2
      action = up
      succeeds = down 
    OrderedPair op3 
      action = up
      succeeds = switch 
}
