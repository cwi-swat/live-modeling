/**/// Commandstypedef struct {  char id;  int argument;} Command;// Allowed commandsconst char MR = 'R';const char ML = 'L';const char SR = 'S';const char SL = 'T';const char NIL = 'I'; // idle const int currCmdSize = 2;Command currentCmds[currCmdSize];// Arduino pinsconst int motorLeftUp      = 9;const int motorLeftDown    = 11;const int motorLeftEnable  = 13;const int motorRightUp     = 10;const int motorRightDown   = 8;const int motorRightEnable = 12;const int sensorPin = 3;// Robot parametersconst int maxAbsSpeed = 10;void setup() {  // set up motor pins  setupMotors();    // default commands do nothing  Command nil;  nil.id = NIL;  nil.argument = 0;  currentCmds[0] = nil;  currentCmds[1] = nil;}void setupMotors() {  pinMode(motorLeftUp, OUTPUT);   pinMode(motorLeftDown, OUTPUT);   pinMode(motorLeftEnable, OUTPUT);    pinMode(motorRightUp, OUTPUT);   pinMode(motorRightDown, OUTPUT);   pinMode(motorRightEnable, OUTPUT);}void loop() {  // recieve message    // parse commands from the message  // string msg = String(p);  //char[] package  // if(msg.length() > 0)  //  parseMessage(msg);    // run commands  for(i = 0; i < currCmdSize; i++)    runTheCommand(currentCmds[i]);      // send a message with the sensor info  //... sensorLine() ...}// Parse the received message into current commandsvoid parseMessage(string msg) {  int a = 0;  int b = searchForChar(msg, ' ', 0);  int c = 0;    while(a < b && b <= msg.length() && c < currCmdSize) {    currentCmds[c].id = msg.charAt(a);//substring(a, b);    a = b + 1;    b = searchForChar(msg, ' ', a);    if (msg.charAt(a) == '-' || isDigit(msg.charAt(a))) {      currentCmds[c].argument = msg.substring(a, b).toInt();      a = b + 1;      b = searchForChar(msg, ' ', a);    }    c++;  }}int searchForChar(string str, char c, int start) {  int i = str.indexOf(c, start);  if (i > 0)     return i;  else if (i == -1)    return str.length();}void runTheCommand(Command cmd) {  switch(cmd.id) {    case MR: moveRightMotor(cmd.argument);      return;    case ML: moveLeftMotor(cmd.argument);      return;    case SR: stopRightMotor();      return;    case SL: stopLeftMotor();      return;    default:      return;  }  }// Hardware functionsvoid moveRightMotor(int speed) {  moveMotor(motorRightUp, motorRightDown, motorRightEnable, speed);}void moveLeftMotor(int speed) {  moveMotor(motorLeftUp, motorLeftDown, motorLeftEnable, speed);}void moveMotor(int motorUp, int motorDown, int motorEna, int speed) {  // map speed to voltage  analogWrite(motorEna, map(abs(speed), 0, maxAbsSpeed, 0 , 255); );  // set the direction of rotation  if(speed > 0) {    digitalWrite(motorUp, HIGH);    digitalWrite(motorDown, LOW);    }   else {    digitalWrite(motorUp, LOW);    digitalWrite(motorDown, HIGH);  } }void stopRightMotor() {  stopMotor(motorRightEnable);  }void stopLeftMotor() {  stopMotor(motorLeftEnable);  }void stopMotor(int motorEna) {  analogWrite(motorEna, 0);  }int sensorLine() {  return digitalRead(sensorPin);}